/**
 * Cloudflare worker for finding all possible equations
 *	that equal 10, given 4 digits 0-9
 *  e.g. '1234', ['1+2+3+4','2*3+4*1',...]
 * 
 * Uses equation_map.json (generated by equation_generator.py) 
 *	which contains all possible equations using +,-,*,/ and one set of ()
 * 	for any given 4-digit number pattern (AAAA, AAAB, AABB, AABC, ABCD)
 * 
 */
import eq_map from './equation_map';
const symbols = [ ['+','-'], ['*','/'], ['(',')'], ['a','b','c','d'] ];
const target_num = 10;

// number = '3114'
// returns { pattern, scope } where pattern = 'aabc', scope = { a: 1, b: 3, c: 4 }
async function getPatternScope(num_str) {
	if (typeof num_str != 'string' || num_str.length != 4) return;
	let num_arr = num_str.split('').map(n => parseInt(n));
    num_arr.sort();
    let num_freq = {};
    num_arr.forEach((n) => {
        if (typeof n != 'number' || n > 9 || n < 0) return;
        num_freq[n] = num_freq[n] ? num_freq[n] + 1 : 1
    });

	const num_freq_order = Object.keys(num_freq).sort((a,b) => num_freq[b] - num_freq[a]);
	let pattern = '';
	const scope = {};
	num_freq_order.forEach((n,i) => {
		pattern += symbols[3][i].repeat(num_freq[n]);
		scope[symbols[3][i]] = n;
	});

	return { pattern, scope };
}

async function findEquations(pattern, scope) {
    let solutions = [];
	for (let i = 0; i < eq_map[pattern].length; i++) {
		// Evaluate postfix expression
		let expr = eq_map[pattern][i][1].split('');
		if (expr.length !== 7) continue;
		let num_stack = [];
		expr.forEach(x => {
			if (symbols[3].includes(x)) {
				num_stack.push(parseInt(scope[x]));
			}
			else if (symbols[0].includes(x) || symbols[1].includes(x)) {
				let num_r = num_stack.pop();
				let num_l = num_stack.pop();
				if (x === '+') num_stack.push(num_l + num_r);
				else if (x === '-') num_stack.push(num_l - num_r);
				else if (x === '*') num_stack.push(num_l * num_r);
				else if (x === '/' && num_r !== 0) num_stack.push(num_l / num_r);
			}
		});
		if (num_stack[num_stack.length-1] === target_num) {
			let solution = eq_map[pattern][i][0].split('');
			solution = solution.map(s => symbols[3].includes(s) ? scope[s] : s).join('');
			solutions.push(solution);
		}
	}
	return solutions;
};

const initResponse = {
	headers: {
		'Content-Type': 'application/json;charset=utf-8'
	}
};

export default {
	async fetch(request, env, ctx) {
		let num = request.url.pathname.slice(1);
		let num_count = 0;

		num.split('').forEach(n => {
			if (parseInt(n) == n) {
				num_count++;
			}
		});

		if (num_count !== 4) {
			return new Response({ error: 'Invalid request'}, { ...initResponse, status: 403 });
		}

		let num_parsed = parseInt(num.split('').sort().join(''));
		let solutions = await env.SOLVER_KV.get(num_parsed.toString());
		if (solutions) return new Response(solutions, initResponse);

		const { pattern, scope } = await getPatternScope(num);

		if (!pattern) return new Response({ error: 'Invalid input'}, { ...initResponse, status: 403 });
		
		const equations = await findEquations(pattern, scope);

		ctx.waitUntil(env.SOLVER_KV.put(num_parsed.toString(), JSON.stringify(equations)));
		
		return new Response(JSON.stringify(equations), initResponse);
	},
};
